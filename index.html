<!DOCTYPE html>
<html lang="en" style="width:100%;height:100%;margin:0;padding:0;">
<head>
    <meta charset="UTF-8">
    <title>ASCT Bubble Treemaps</title>
    <script type='text/javascript' src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <script type='text/javascript' src="https://d3js.org/d3.v7.js"></script>
    <script type='text/javascript' src="https://cdn.jsdelivr.net/npm/planck@latest/dist/planck-with-testbed.min.js"></script>
    <script type='text/javascript' src="./build/d3-bubbletreemap.js"></script>
    <script>
        const childrenAccessorFn = ([, value]) => value instanceof Map && Array.from(value);
        const dataAccessorFn = ({ data }) => (data[1] && data[1][0]) || {}
        const titleAccessorFn = ({ data }) => data[0] ?? ''
        const LabelingMethod = {
          TopLeaves: 0,
          TopASNodes: 1,
          FTUNodes: 2
        }
        const CellSuperType = {
          Vasculature: 1,
          Lymph: 2,
          Nerve: 3,
          Others: 4,
          Immune: 5,
          Connective: 6,
          Muscle: 7
        };
        const CellSuperTypeLabel = {
          [CellSuperType.Vasculature]: 'Vasculature',
          [CellSuperType.Lymph]: 'Lymph',
          [CellSuperType.Nerve]: 'Nerve',
          [CellSuperType.Others]: 'Others',
          [CellSuperType.Immune]: 'Immune',
          [CellSuperType.Connective]: 'Connective',
          [CellSuperType.Muscle]: 'Muscle',
        };

        var ASCT_CSV_DATA_SOURCE = null;
        var COUNT_CSV_DATA_SOURCE = null;
        var AS_ROOT_TITLE = null;
        var CIRCLE_RADIUS = 8;
        var CONTOUR_WIDTH = 3;
        var LOG_SCALE_FACTOR = 4; // Eg: log_e(7.3890561) => 2
        var TOOLTIP_PATH_START_LEVEL = 0; // 0-indexed
        var TOP_N_LEAVES = 10;
        var TOP_AS_MIN_CHILDREN = 5;
        var SELECTED_LABELING_METHOD = LabelingMethod.TopLeaves;
        var countCsvData = null;
        var countMap = new Map();
        var colorMap = new Map();
        var renderedSVGSize;
        var topNLabels, topNLeaves, topNLeafParents, topNLabelsNode, ftuNodes;

        let working = false;

        async function generateTreemap() {
          document.getElementById('busyText').style.display = 'inline';
          countMap.clear();
          await getCellCount();
          d3.text(ASCT_CSV_DATA_SOURCE).then(rootData => {
            const csvData = d3.csvParse(rootData.split('\n').slice(10).join('\n'));
            if (!working) {
              working = true;

              const treeData = groupTreeData(csvData);
              if (treeData) {
                let svg = d3.select("#svgCircles");
                svg.selectAll("*").remove();

                let padding = Number(document.getElementById("paddingSlider").value);
                let curvature = Number(document.getElementById("curvatureSlider").value);

                drawChart(treeData, svg, padding, (curvature === 100 ? 100000 : curvature));
              }
              working = false;
              document.getElementById('busyText').style.display = 'none';
            }
          });
        }

        function compressTree(nestedMap) {
          for (const [key, value] of nestedMap.entries()) {
            if (value instanceof Map) {
              compressTree(value);
              if (key === '') {
                let skipDelete = false;
                for (const [nkey, nvalue] of value.entries()) {
                  skipDelete |= nkey === key;
                  nestedMap.set(nkey, nvalue);
                }
                !skipDelete && nestedMap.delete(key);
              } else if (value.has('') && value.size === 1) {
                nestedMap.set(key, value.get(''));
              }
            }
          }
        }

        async function getCellCount() {
          if (!COUNT_CSV_DATA_SOURCE) return Promise.resolve();
          return d3.text(COUNT_CSV_DATA_SOURCE)
            .then(rootData => {
              countCsvData = d3.csvParse(rootData.split('\n').slice(10).join('\n'));
              const groupedData = groupTreeData(countCsvData);
              computeCellCount(groupedData);
              // console.table(Array.from(countMap));
            });
        }

        function computeCellCount(nestedMap) {
          let totalCount = 0;
          if (nestedMap instanceof Array) {
            if (!nestedMap[0]) return;
            return parseInt(nestedMap[0][countCsvData.columns.find(c => /^AS\/[0-9]+\/COUNT$/i.test(c))]);
          }
          for (const [key, value] of nestedMap.entries()) {
            countMap.set(key, computeCellCount(value));
            totalCount += countMap.get(key);
          }
          return totalCount;
        }

        function getCountMapKey(cellId) {
          if (!cellId && cellId !== 0) return;
          return Array.from(countMap.keys()).find(key => new RegExp(key, 'i').test(cellId));
        }

        function groupTreeData(csvData) {
          const groupedData = d3.group(csvData, ...csvData.columns
            .filter(c => /^(AS|CT)\/[0-9]+$/.test(c))
            .sort((labelA, labelB) => { 
              const [typeA, levelA] = labelA.split('/');
              const [typeB, levelB] = labelB.split('/');
              return typeA.localeCompare(typeB) || parseInt(levelA) - parseInt(levelB)
            })
            .map(c => (d) => d[c]));
          compressTree(groupedData);
          return groupedData;
        }

        function computeTopNLeaves(leaves, n) {
          const labels = new Set();
          const sortedLeaves = leaves.filter(d => d.value > CIRCLE_RADIUS).sort((a, b) => b.value - a.value);

          const topNLeaves = [];
          for (const leaf of sortedLeaves) {
            if (labels.size === n) break;
            labels.add(titleAccessorFn(leaf));
            topNLeaves.push(leaf);
          }
          return topNLeaves;
        }

        function drawChart(data, svg, padding, curvature) {
            // Create hierarchy.
          let root = d3.hierarchy(Array.from(data)[0], childrenAccessorFn)
            .sum(data => {
              // Intermediate node check, return the set size
              if (data.size) return 0;
              // Leaf node, check if count is available in the typology sheet
              const leaf = dataAccessorFn({ data });
              // TODO: Remove adhoc code that gets countMapKey based on CT/1 or CT/1/LABEL.
              // This should always be fetched based on CT/1/ID.
              const countMapKey = getCountMapKey(leaf['CT/1']) ?? getCountMapKey(leaf['CT/1/LABEL']);
              return countMapKey ? CIRCLE_RADIUS * (Math.log(countMap.get(countMapKey)) / Math.log(LOG_SCALE_FACTOR)) : CIRCLE_RADIUS;
            })
            .sort((a, b) => b.value - a.value);

          root.descendants().forEach(node => node.uncertainty = node.height * 2 + 1);

          renderedSVGSize = svg.node().getBoundingClientRect();

          // Create bubbletreemap.
          let bubbletreemap = d3.bubbletreemap()
              .padding(padding)
              .curvature(curvature)
              .hierarchyRoot(root)
              .width(renderedSVGSize.width - 400)
              .height(renderedSVGSize.height)
              .colormap(colorMap);

          // Do layout and coloring.
          let hierarchyRoot = bubbletreemap.doLayout().doColoring().hierarchyRoot();

          const leaves = root.leaves();
          const leafParentsCandidates = new Set(leaves.map(leaf => leaf.parent));
          const leafParents = [];
          for (let node of leafParentsCandidates.keys()) {
            // Skip parent if their child is already a candidate
            if (node.children.some(c => leafParentsCandidates.has(c))) continue;
            leafParents.push(node);
          }
          ftuNodes = Array.from(new Set(leaves.filter(d => dataAccessorFn(d)['FTU']).map(d => d.parent)));
          [...leafParents, ...ftuNodes].sort((a, b) => b.depth - a.depth)
            .forEach((d) =>
              Object.assign(d, getCircleCentroid(d.children))
            );

          // Draw contour.
          let contourGroup = svg.append("g")
            .attr("class", "contour")
            .selectAll("path")
            .data(bubbletreemap.getContour())
            .enter()
              .append("path")
              .attr("d", function(arc) { return arc.d; })
              .attr('data-structure-type', (arc) => titleAccessorFn(arc.parent))
              .style("stroke", function(arc) { return arc.stroke; })
              .style("stroke-width", function(arc) { return arc.strokeWidth; })
              .attr("transform", function(arc) { return arc.transform; });

          contourGroup.append("title")
            .text(function (arc) {
              const asPath = getASPath(arc.parent);
              const title = titleAccessorFn(arc.parent);
              return title + (asPath ? `\n\nAS Tree: ${asPath}` : '')
            });

          // Draw circles.
          let circleGroup = svg.append("g")
              .attr("class", "circles")
              .selectAll("circle")
              .data(leaves)
              .enter()
                .append("circle")
                .classed('circle', true)
                .attr('data-cell-type', (d) => titleAccessorFn(d))
                .attr("r", function(d) { return d.r })
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; })
                .style("fill", function(d) { return dataAccessorFn(d)['CT/1'] ? d.color : '#222222' })
                .style("stroke", "black")
                .style("stroke-width", "2");
            
          // Add Hover Text
          circleGroup.append("title")
            .text(function (d) {
              const data = dataAccessorFn(d);
              const countMapKey = getCountMapKey(data['CT/1']) || getCountMapKey(data['CT/1/LABEL']);
                return `${data['CT/1']}${countMap.has(countMapKey) ? ' ('+ countMap.get(countMapKey) +')' : ''}\n\nAS Tree: ${getASPath(d)}`
            });

          // Add Top-N Labels
          topNLeaves = computeTopNLeaves(leaves, TOP_N_LEAVES);
          topNLeafParents = leafParents.filter(p => p.children.length >= TOP_AS_MIN_CHILDREN);
          switch (SELECTED_LABELING_METHOD) {
            case LabelingMethod.TopLeaves:
              topNLabels = topNLeaves;
              break;
            case LabelingMethod.TopASNodes:
              topNLabels = topNLeafParents;
              break;
            case LabelingMethod.FTUNodes:
              topNLabels = ftuNodes;
              break;
          }
          topNLabelsNode = svg.append('g')
            .style('font-family', 'Verdana, Geneva, Tahoma, sans-serif')
            .style('text-anchor', 'middle')
            .style('fill', 'white')
            .style('paint-order', 'stroke')
            .style('stroke', '#444')
            .style('stroke-width', '4px')
            .style('stroke-linejoin', 'round')
            .style('letter-spacing', '1px');

          topNLabelsNode.selectAll(".label")
            .data(topNLabels)
            .enter()
            .append("text")
              .classed("label", true)
              .text((d) => titleAccessorFn(d))
              .attr("transform", function (d) {
                return "translate(" + [d.x, d.y] + ")";
              })
            
          // Add Title Text
          svg.append("text")
            .attr("transform", "translate(" + [renderedSVGSize.width / 2, 100] + ")")
            .attr("text-anchor", "middle")
            .text(`${AS_ROOT_TITLE} Partonomy`)
            .style('font-family', 'Cambria,Cochin,Georgia,Times,Times New Roman,serif')
            .style('font-size', 84)
            .style('font-weight', 800);

          drawLegends(root, svg);
        }

        function getCircleCentroid(circles) {
          // Calculate centroid of circle group.
          let circleMassSum = 0;
          let centroid = planck.Vec2.zero();

          circles.forEach(function (circle) {
            let circleMass = circle.r * circle.r * Math.PI;
            circleMassSum += circleMass;
            centroid.x += circle.x * circleMass;
            centroid.y += circle.y * circleMass;
          });

          centroid.mul(1.0 / circleMassSum);

          return centroid;
        }

        function getASPath(node) {
          const pathList = getPathList(node);
          return pathList.splice(TOOLTIP_PATH_START_LEVEL).join(' > ')
        }

        function getPathList(node) {
          if (!node.parent) return [titleAccessorFn(node)];
          const pathList = getPathList(node.parent);
          pathList.push(titleAccessorFn(node));
          return pathList;
        }

        function changeLabelingMethod(methodType) {
          SELECTED_LABELING_METHOD = methodType;
          topNLabelsNode.selectChildren().remove();
          switch(methodType) {
            case LabelingMethod.TopLeaves:
              topNLabels = topNLeaves;
              break;
            case LabelingMethod.TopASNodes:
              topNLabels = topNLeafParents;
              break;
            case LabelingMethod.FTUNodes:
              topNLabels = ftuNodes;
              break;
          }
          topNLabelsNode.selectAll('.label')
            .data(topNLabels)
            .enter()
              .append("text")
              .classed("label", true)
              .text((d) => titleAccessorFn(d))
              .attr("transform", function (d) {
                return "translate(" + [d.x, d.y] + ")";
              })
        }

        function drawLegends(rootData, svg) {
          var legendHeight = 20,
            colorWidth = legendHeight * 3,
            interLegend = 4,
            legendNodes = Array.from(colorMap)
              .map(([key1, key2]) => [
                  CellSuperTypeLabel[key1] ?? key1,
                  key2
              ]).sort(([key1], [key2]) => key2.localeCompare(key1));

          const legendXOffset = 1600;
          const legendYOffset = (renderedSVGSize.height + legendNodes.length * 24) / 2;
          var legendContainer = svg.append('g')
            .classed('legend', true)
            .attr('transform', 'translate(' + [legendXOffset, legendYOffset] + ')')
            .style('font-family', 'Verdana, Geneva, Tahoma, sans-serif')
            .style('stroke', '#444')
            .style('fill', '#444');

          var legends = legendContainer.selectAll('.legend')
            .data(legendNodes)
            .enter();

          var legend = legends.append('g')
            .classed('legend', true)
            .attr('transform', function (d, i) {
              return 'translate(' + [0, -i * (legendHeight + interLegend)] + ')';
            })

          legend.append('rect')
            .classed('legend-color', true)
            .attr('y', -legendHeight)
            .attr('width', colorWidth)
            .attr('height', legendHeight)
            .style('fill', function (d) { return d[1] });

          legend.append('text')
            .classed('legend-text', true)
            .attr('transform', 'translate(' + [colorWidth + 5, -4] + ')')
            .text(function (d) { return d[0] });

          legendContainer.append('text')
            .attr('transform', 'translate(' + [0, -legendNodes.length * (legendHeight + interLegend) - 5] + ')')
            .style('font-size', '1.2em')
            .text('Cell Types');
        }
        
        function updateOrganSelection(selectEl) {
          ASCT_CSV_DATA_SOURCE = `./html/ASCT+B_Tables_Standard_Format_3-24-2021_-_${selectEl.value}.csv`;
          switch (selectEl.value) {
            case 'Brain_v1':
              AS_ROOT_TITLE = 'Brain';
              COUNT_CSV_DATA_SOURCE = './html/motor_cortex.csv';
              colorMap.clear();
              break;
            case 'Heart_v1':
              AS_ROOT_TITLE = 'Heart';
              COUNT_CSV_DATA_SOURCE = null;
              colorMap.clear();
              break;
            case 'Kidney_v1':
              AS_ROOT_TITLE = 'Kidney';
              COUNT_CSV_DATA_SOURCE = null;
              colorMap.clear();
              break;
            case 'Large_Intestine_v1':
              AS_ROOT_TITLE = 'Large Intestine';
              COUNT_CSV_DATA_SOURCE = null;
              colorMap.clear();
              break;
            case 'Lymph_Node_v1':
              AS_ROOT_TITLE = 'Lymph Node';
              COUNT_CSV_DATA_SOURCE = null;
              colorMap.clear();
              break;
            case 'Lung_v1':
              AS_ROOT_TITLE = 'Lung';
              COUNT_CSV_DATA_SOURCE = null;
              colorMap.clear();
              break;
            case 'Spleen_v1.6':
              AS_ROOT_TITLE = 'Spleen';
              COUNT_CSV_DATA_SOURCE = './html/azimuth-spleen-cell-sets.json.csv';
              colorMap = new Map([
                [CellSuperType.Vasculature.toString(), '#d53e4f'],
                [CellSuperType.Lymph.toString(), '#998ec3'],
                [CellSuperType.Nerve.toString(), '#99d594'],
                [CellSuperType.Others.toString(), '#fc8d59'],
                [CellSuperType.Immune.toString(), '#fee08b'],
                [CellSuperType.Connective.toString(), '#3288bd'],
                [CellSuperType.Muscle.toString(), '#999999'],
              ]);
            break;
            case 'Skin_v1':
              AS_ROOT_TITLE = 'Skin';
              COUNT_CSV_DATA_SOURCE = null;
              colorMap.clear();
              break;
            case 'Thymus_v1':
              AS_ROOT_TITLE = 'Thymus';
              COUNT_CSV_DATA_SOURCE = null;
              colorMap.clear();
              break;
            case 'Vasculature_v1':
              AS_ROOT_TITLE = 'Vasculature';
              COUNT_CSV_DATA_SOURCE = null;
              colorMap.clear();
              break;
            default:
            COUNT_CSV_DATA_SOURCE = null;
            colorMap.clear();
          }
        }
    </script>
    <style>
      .circle:hover {
        stroke: gray !important;
        stroke-width: 3 !important;
      }
    </style>
</head>
<body onload="updateOrganSelection({ value: 'Spleen_v1.6' });generateTreemap()">
    <select name="organs" onchange="updateOrganSelection(this)">
      <option value="Brain_v1">Brain</option>
      <option value="Heart_v1" disabled title="This dataset is too large.">Heart</option>
      <option value="Kidney_v1">Kidney</option>
      <option value="Large_Intestine_v1">Large Intestine</option>
      <option value="Lymph_Node_v1">Lymph Node</option>
      <option value="Lung_v1" disabled title="This dataset is too large.">Respiratory System</option>
      <option value="Spleen_v1.6" selected="selected">Spleen</option>
      <option value="Skin_v1">Skin</option>
      <option value="Thymus_v1">Thymus</option>
      <option value="Vasculature_v1">Vasculature</option>
    </select>
    <a href="https://docs.google.com/document/d/1D7fG5brd2iq58SUU1Uv3Qdal1X8Fzhy5tRiZA0HGeII/edit?usp=sharing" style="float:right">About</a>
    <button onclick="generateTreemap()">Generate SVG</button>
    <small style="color: gray; display: none" id="busyText">Generating bubble treemap, please wait...</small>
    <br /><br />
    <input type="radio" name="nodeLabels" id="topLeavesOpt" onchange="changeLabelingMethod(0)" checked>
    <label for="topLeavesOpt">Top 10 Leaves</label>
    <input type="radio" name="nodeLabels" id="topASNodesOpt" onchange="changeLabelingMethod(1)">
    <label for="topLeavesOpt">Top AS Nodes</label>
    <input type="radio" name="nodeLabels" id="ftuNodesOpt" onchange="changeLabelingMethod(2)">
    <label for="ftuNodesOpt">FTU Nodes</label>
    <div id="svgCirclesContainer">
        <svg id="svgCircles" width="2000px" height="1700px"></svg>
    </div>

    <div style="position: absolute; left:20px; bottom:40px;display:none" id="paddingSliderContainer">
        Padding: <input style="background:grey;position: absolute; left:100px" type="range" min="0" max="100" value="10" class="slider" id="paddingSlider" onchange="generateTreemap()">
    </div>
    <div style="position: absolute; left:20px; bottom:80px;display:none" id="curvatureSliderContainer">
        Smoothness: <input style="background:grey;position: absolute; left:100px" type="range" min="1" max="100" value="10" class="slider" id="curvatureSlider" onchange="generateTreemap()">
    </div>
</body>
</html>
