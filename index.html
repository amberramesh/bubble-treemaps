<!DOCTYPE html>
<html lang="en" style="width:100%;height:100%;margin:0;padding:0;">
<head>
    <meta charset="UTF-8">
    <title>ASCT Bubble Treemaps</title>
    <script type='text/javascript' src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
    <script type='text/javascript' src="https://d3js.org/d3.v7.js"></script>
    <script type='text/javascript' src="https://cdn.jsdelivr.net/npm/planck@latest/dist/planck-with-testbed.min.js"></script>
    <script type='text/javascript' src="./build/d3-bubbletreemap.js"></script>
    <script>
        const childrenAccessorFn = ([, value]) => value instanceof Map && Array.from(value);
        const dataAccessorFn = ({ data }) => (data[1] && data[1][0]) || {}
        const titleAccessorFn = ({ data }) => data[0] ?? ''
        const LabelingMethod = {
          TopLeaves: 0,
          TopASNodes: 1,
          FTUNodes: 2
        }
        const CellSuperType = {
          Vasculature: 1,
          Lymph: 2,
          Nerve: 3,
          Others: 4,
          Immune: 5,
          Connective: 6,
          Muscle: 7
        };
        const CTMatchType = {
          ID: 0,
          Name: 1
        };
        const CellSuperTypeLabel = {
          [CellSuperType.Vasculature]: 'Vasculature',
          [CellSuperType.Lymph]: 'Lymph',
          [CellSuperType.Nerve]: 'Nerve',
          [CellSuperType.Others]: 'Others',
          [CellSuperType.Immune]: 'Immune',
          [CellSuperType.Connective]: 'Connective',
          [CellSuperType.Muscle]: 'Muscle',
        };

        var ASCT_CSV_DATA_SOURCE = null;
        var COUNT_CSV_DATA_SOURCE = null;
        var AS_ROOT_TITLE = null;
        var CT_MATCH_TYPE = CTMatchType.ID;
        var CIRCLE_RADIUS = 8;
        var FTU_CIRCLE_RADIUS = 50;
        var CONTOUR_WIDTH = 3;
        var LOG_SCALE_BASE = 4; // Eg: log_e(7.3890561) => 2
        var TOOLTIP_PATH_START_LEVEL = 0; // 0-indexed
        var TOP_N_LEAVES = 10;
        var TOP_AS_MIN_CHILDREN = 5;
        var SELECTED_LABELING_METHOD = LabelingMethod.TopLeaves;
        var countCsvData = null;
        var countMap = new Map();
        var colorMap = new Map();
        var renderedSVGSize;
        var topNLabels, topNLeaves, topNLeafParents, topNLabelsNode, ftuNodes;

        let working = false;

        async function generateTreemap() {
          document.getElementById('busyText').style.display = 'inline';
          countMap.clear();
          await getCellCount();
          d3.text(ASCT_CSV_DATA_SOURCE).then(rootData => {
            const csvData = d3.csvParse(rootData.split('\n').slice(10).join('\n'));
            if (!working) {
              working = true;

              const groupRegex = /^(AS|CT)\/[0-9]+$/;
              const treeData = groupTreeData(csvData, groupRegex);
              if (treeData) {
                let svg = d3.select("#svgCircles");
                svg.selectAll("*").remove();

                let padding = Number(document.getElementById("paddingSlider").value);
                let curvature = Number(document.getElementById("curvatureSlider").value);

                drawChart(treeData, svg, padding, (curvature === 100 ? 100000 : curvature));
              }
              working = false;
              document.getElementById('busyText').style.display = 'none';
            }
          });
        }

        function compressTree(nestedMap) {
          for (const [key, value] of nestedMap.entries()) {
            if (value instanceof Map) {
              if (Array.from(value.entries()).some(data => isFTU({ data }))) {
                nestedMap.set(key, [{
                  FTU: true
                }])
              }
              compressTree(value);
              if (key === '') {
                let skipDelete = false;
                for (const [nkey, nvalue] of value.entries()) {
                  skipDelete |= nkey === key;
                  nestedMap.set(nkey, nvalue);
                }
                !skipDelete && nestedMap.delete(key);
              } else if (value.has('') && value.size === 1) {
                nestedMap.set(key, value.get(''));
              }
            }
          }
        }

        async function getCellCount() {
          if (!COUNT_CSV_DATA_SOURCE) return Promise.resolve();
          return d3.text(COUNT_CSV_DATA_SOURCE)
            .then(rootData => {
              countCsvData = d3.csvParse(rootData.split('\n').slice(10).join('\n'));
              const groupRegex = CT_MATCH_TYPE === CTMatchType.ID ? /^(AS|CT)\/[0-9]+\/ID$/ : /^(AS|CT)\/[0-9]+$/
              const groupedData = groupTreeData(countCsvData, groupRegex);
              computeCellCount(groupedData);
              countMap.delete('');
              // console.table(Array.from(countMap));
            });
        }

        function computeCellCount(nestedMap) {
          let totalCount = 0;
          if (nestedMap instanceof Array) {
            if (!nestedMap[0]) return;
            return parseInt(nestedMap[0][countCsvData.columns.find(c => /^AS\/[0-9]+\/COUNT$/i.test(c))]);
          }
          for (const [key, value] of nestedMap.entries()) {
            countMap.set(key, computeCellCount(value));
            totalCount += countMap.get(key);
          }
          return totalCount;
        }

        function getCountMapKey(node) {
          const data = dataAccessorFn(node);
          const identifiers = CT_MATCH_TYPE === CTMatchType.ID ? ['CT/1/ID'] : ['CT/1', 'CT/1/LABEL'];
          for (const ctId of identifiers) {
            if (!ctId) continue;
            const key = Array.from(countMap.keys()).find(key => new RegExp(`^${key}$`, 'i').test(data[ctId]));
            if (key) return key;
          }
        }

        function groupTreeData(csvData, groupRegex) {
          const groupedData = d3.group(csvData, ...csvData.columns
            .filter(c => groupRegex.test(c))
            .sort((labelA, labelB) => { 
              const [typeA, levelA] = labelA.split('/');
              const [typeB, levelB] = labelB.split('/');
              return typeA.localeCompare(typeB) || parseInt(levelA) - parseInt(levelB)
            })
            .map(c => (d) => d[c]));
          compressTree(groupedData);
          return groupedData;
        }

        function isFTU(node) {
          if (Array.isArray(node.children)) {
            for (const child of node.children) {
              if (!!dataAccessorFn(child)['FTU']) {
                return true
              }
            }
            return false;
          } else {
            return !!dataAccessorFn(node)['FTU']
          }
        }

        function isCellTypeNode(node) {
          if (Array.isArray(node.data)) {
            const [key, value] = node.data;
            if (Array.isArray(value)) {
              return !!value[0]['CT/1'];
            }
          }
          return false;
        }

        function computeTopNLeaves(leaves, n) {
          const labels = new Set();
          const sortedLeaves = leaves.filter(d => isCellTypeNode(d) && d.value > CIRCLE_RADIUS).sort((a, b) => b.value - a.value);

          const topNLeaves = [];
          let lastSize = Number.MAX_VALUE;
          for (const leaf of sortedLeaves) {
            if (labels.size >= n && leaf.value < lastSize) break;
            labels.add(titleAccessorFn(leaf));
            topNLeaves.push(leaf);
            lastSize = leaf.value;
          }
          return topNLeaves;
        }

        function drawChart(data, svg, padding, curvature) {
            // Create hierarchy.
          let root = d3.hierarchy(Array.from(data)[0], childrenAccessorFn)
            .sum(data => {
              // Intermediate node check
              const [key, value] = data;
              if (value instanceof Map) return 0;
              if (value[0].FTU) return FTU_CIRCLE_RADIUS;
              // Leaf node, check if count is available in the typology sheet
              const countMapKey = getCountMapKey({ data });
              // Actual circle size is CIRCLE_RADIUS * log(count)
              // When count falls below LOG_SCALE_BASE, its log is a fractional unit.
              // Sizes are never below CIRCLE_RADIUS, so the next size class is used instead.
              return countMapKey ? CIRCLE_RADIUS * (Math.max(Math.log(countMap.get(countMapKey)) / Math.log(LOG_SCALE_BASE), 1)) : CIRCLE_RADIUS;
            })
            .sort((a, b) => b.value - a.value);

          root.descendants().forEach(node => node.uncertainty = node.height * 2 + 1);

          renderedSVGSize = svg.node().getBoundingClientRect();

          // Create bubbletreemap.
          let bubbletreemap = d3.bubbletreemap()
              .padding(padding)
              .curvature(curvature)
              .hierarchyRoot(root)
              .width(renderedSVGSize.width - 900)
              .height(renderedSVGSize.height)
              .colormap(colorMap);

          // Do layout and coloring.
          let hierarchyRoot = bubbletreemap.doLayout().doColoring().hierarchyRoot();

          const leaves = root.leaves();
          const leafParentsCandidates = new Set(leaves.map(leaf => leaf.parent));
          const leafParents = [];
          for (let node of leafParentsCandidates.keys()) {
            // Skip parent if their child is already a candidate
            if (node.children.some(c => leafParentsCandidates.has(c))) continue;
            leafParents.push(node);
          }
          ftuNodes = Array.from(new Set(leaves.filter(isFTU).map(d => d)));
          leafParents.sort((a, b) => b.depth - a.depth)
            .forEach((d) =>
              Object.assign(d, getCircleCentroid(d.children))
            );

          // Draw contour.
          let contourGroup = svg.append("g")
            .attr("class", "contour")
            .selectAll("path")
            .data(bubbletreemap.getContour())
            .enter()
              .append("path")
              .attr("d", function(arc) { return arc.d; })
              .attr('data-structure-type', (arc) => titleAccessorFn(arc.parent))
              .style("stroke", function(arc) { return arc.stroke; })
              .style("stroke-width", function(arc) { return arc.strokeWidth; })
              .attr("transform", function(arc) { return arc.transform; });

          contourGroup.append("title")
            .text(function (arc) {
              const asPath = getASPath(arc.parent);
              const title = titleAccessorFn(arc.parent);
              return title + (asPath ? `\n\nAS Tree: ${asPath}` : '')
            });

          // Draw circles.
          let circleGroup = svg.append("g")
              .attr("class", "circles")
              .selectAll("circle")
              .data(leaves.filter(d => !isFTU(d)))
              .enter()
                .append("circle")
                .classed('circle', true)
                .attr('data-cell-type', (d) => titleAccessorFn(d))
                .attr("r", function(d) { return d.r })
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; })
                .style("fill", function(d) { return dataAccessorFn(d)['CT/1'] ? d.color : '#222222' })
                .style("stroke", "black")
                .style("stroke-width", "2");
            
          // Add Hover Text
          circleGroup.append("title")
            .text(function (d) {
              const countMapKey = getCountMapKey(d);
                return `${titleAccessorFn(d)}${countMap.has(countMapKey) ? ' ('+ countMap.get(countMapKey) +')' : ''}\n\nAS Tree: ${getASPath(d)}`
            });

          // Add Top-N Labels
          topNLeaves = computeTopNLeaves(leaves, TOP_N_LEAVES);
          topNLeafParents = leafParents.filter(p => p.children.length >= TOP_AS_MIN_CHILDREN);
          switch (SELECTED_LABELING_METHOD) {
            case LabelingMethod.TopLeaves:
              topNLabels = topNLeaves;
              break;
            case LabelingMethod.TopASNodes:
              topNLabels = topNLeafParents;
              break;
            case LabelingMethod.FTUNodes:
              topNLabels = ftuNodes;
              break;
          }
          topNLabelsNode = svg.append('g')
            .style('font-family', 'Verdana, Geneva, Tahoma, sans-serif')
            .style('text-anchor', 'middle')
            .style('fill', 'black')
            .style('paint-order', 'stroke')
            .style('stroke', 'black')
            .style('stroke-width', '1px')
            .style('stroke-linejoin', 'round');

          topNLabelsNode.selectAll(".label")
            .data(topNLabels)
            .enter()
            .append("text")
              .classed("label", true)
              .text((d) => titleAccessorFn(d))
              .attr("transform", function (d) {
                return "translate(" + [d.x, d.y] + ")";
              })
            
          // Add Title Text
          svg.append("text")
            .attr("transform", "translate(" + [renderedSVGSize.width / 2, 100] + ")")
            .attr("text-anchor", "middle")
            .text(`${AS_ROOT_TITLE} Partonomy`)
            .style('font-family', 'Cambria,Cochin,Georgia,Times,Times New Roman,serif')
            .style('font-size', 84)
            .style('font-weight', 800);

          drawLegends(root, svg);
        }

        function getCircleCentroid(circles) {
          // Calculate centroid of circle group.
          let circleMassSum = 0;
          let centroid = planck.Vec2.zero();

          circles.forEach(function (circle) {
            let circleMass = circle.r * circle.r * Math.PI;
            circleMassSum += circleMass;
            centroid.x += circle.x * circleMass;
            centroid.y += circle.y * circleMass;
          });

          centroid.mul(1.0 / circleMassSum);

          return centroid;
        }

        function getASPath(node) {
          const pathList = getPathList(node);
          return pathList.splice(TOOLTIP_PATH_START_LEVEL).join(' > ')
        }

        function getPathList(node) {
          if (!node.parent) return [titleAccessorFn(node)];
          const pathList = getPathList(node.parent);
          pathList.push(titleAccessorFn(node));
          return pathList;
        }

        function changeLabelingMethod(methodType) {
          SELECTED_LABELING_METHOD = methodType;
          topNLabelsNode.selectChildren().remove();
          switch(methodType) {
            case LabelingMethod.TopLeaves:
              topNLabels = topNLeaves;
              break;
            case LabelingMethod.TopASNodes:
              topNLabels = topNLeafParents;
              break;
            case LabelingMethod.FTUNodes:
              topNLabels = ftuNodes;
              break;
          }
          topNLabelsNode.selectAll('.label')
            .data(topNLabels)
            .enter()
              .append("text")
              .classed("label", true)
              .text((d) => titleAccessorFn(d))
              .attr("transform", function (d) {
                return "translate(" + [d.x, d.y] + ")";
              })
        }

        function drawLegends(rootData, svg) {
          var legendHeight = 20,
            colorWidth = legendHeight * 3,
            interLegend = 4,
            legendNodes = Array.from(colorMap)
              .map(([key1, key2]) => [
                  CellSuperTypeLabel[key1] ?? key1,
                  key2
              ]).sort(([key1], [key2]) => key2.localeCompare(key1));

          let legendXOffset = 1600;
          let legendYOffset = (renderedSVGSize.height + legendNodes.length * 24) / 2;
          var legendContainer = svg.append('g')
            .classed('ct-legend', true)
            .attr('transform', 'translate(' + [legendXOffset, legendYOffset] + ')')
            .style('font-family', 'Verdana, Geneva, Tahoma, sans-serif')
            .style('stroke', '#444')
            .style('fill', '#444');

          var legends = legendContainer.selectAll('.ct-legend-li')
            .data(legendNodes)
            .enter();

          var legend = legends.append('g')
            .classed('ct-legend-li', true)
            .attr('transform', function (d, i) {
              return 'translate(' + [0, -i * (legendHeight + interLegend)] + ')';
            })

          legend.append('rect')
            .classed('legend-color', true)
            .attr('y', -legendHeight)
            .attr('width', colorWidth)
            .attr('height', legendHeight)
            .style('fill', function (d) { return d[1] });

          legend.append('text')
            .classed('legend-text', true)
            .attr('transform', 'translate(' + [colorWidth + 5, -4] + ')')
            .text(function (d) { return d[0] });

          legendContainer.append('text')
            .attr('transform', 'translate(' + [0, -legendNodes.length * (legendHeight + interLegend) - 10] + ')')
            .style('font-size', '1.2em')
            .text('Cell Types');

          const knownCellCounts = rootData.leaves().filter(getCountMapKey).map(d => countMap.get(getCountMapKey(d)));
          const minCount = Math.min(...knownCellCounts);
          const maxCount = Math.max(...knownCellCounts);
          let safeMaxCount = 1, safeMinCount = 1;
          const scaledCountList = [];
          if (maxCount > 0) {
            const minScaledCount = safeMinCount = Math.floor(Math.max(Math.log(minCount) / Math.log(LOG_SCALE_BASE), 1));
            const maxScaledCount = safeMaxCount = Math.floor(Math.max(Math.log(maxCount) / Math.log(LOG_SCALE_BASE), 1));
            const ranges = Array(maxScaledCount - minScaledCount).fill().map((_, i) => maxScaledCount - i - 1);

            scaledCountList.push({
              count: maxScaledCount,
              title: `\u2265 ${Math.pow(LOG_SCALE_BASE, maxScaledCount)}`
            });

            ranges.forEach(min => {
              const max = min + 1, mid = (min + max) / 2;
              scaledCountList.push({
                count: mid,
                // Display range-min as 1 for the lowest size class
                title: `${Math.pow(LOG_SCALE_BASE, min === 1 ? 0 : min)} to ${Math.pow(LOG_SCALE_BASE, max)}`
              });
            })
          }
          if (knownCellCounts.length < rootData.leaves().length) {
            // Scaled count is taken as 1 for unknown counts, so that they are shown with the minimum size.
            safeMinCount = 1;
            scaledCountList.push({
              count: safeMinCount,
              title: 'Unknown'
            });
          }

          interLegend = 10;
          const listHeight = getCountLegendSpacing(scaledCountList, interLegend);
          legendXOffset = legendXOffset + document.querySelector('.ct-legend').getBoundingClientRect().width + 100;
          legendYOffset = (renderedSVGSize.height + listHeight) / 2;
          legendContainer = svg.append('g')
            .classed('cr-legend', true)
            .attr('transform', 'translate(' + [legendXOffset, legendYOffset] + ')')
            .style('font-family', 'Verdana, Geneva, Tahoma, sans-serif')
            .style('stroke', '#444')
            .style('fill', '#444');

          legends = legendContainer.selectAll('.cr-legend-li')
            .data(scaledCountList)
            .enter();

          legend = legends.append('g')
            .classed('cr-legend-li', true)
            .attr('transform', function (d, i) {
              return 'translate(' + [0, -(getCountLegendSpacing(scaledCountList.slice(0, i), interLegend))] + ')';
            })
          
          legend.append('circle')
            .classed('legend-color', true)
            .attr('y', -legendHeight)
            .attr('r', function(d) { return CIRCLE_RADIUS * d.count })

          legend.append('text')
            .classed('legend-text', true)
            .attr('transform', 'translate(' + [CIRCLE_RADIUS * safeMaxCount + 20, 4] + ')')
            .text(function (d) { return d.title });

          legendContainer.append('text')
            .attr('transform', 'translate(' + [-(CIRCLE_RADIUS * safeMaxCount), -listHeight - 5] + ')')
            .style('font-size', '1.2em')
            .text('Cell Count');
        }

        function getCountLegendSpacing(countList, padding = 0) {
          let res = 0;
          for (const { count } of countList) {
            // Diameter of circle with padding
            res += (2 * CIRCLE_RADIUS * count) + padding;
          }
          return res;
        }
        
        function updateOrganSelection(selectEl) {
          ASCT_CSV_DATA_SOURCE = `./html/ASCT+B_Tables_Standard_Format_3-24-2021_-_${selectEl.value}.csv`;
          switch (selectEl.value) {
            case 'Brain_v1':
              AS_ROOT_TITLE = 'Brain';
              COUNT_CSV_DATA_SOURCE = './html/motor_cortex.csv';
              CT_MATCH_TYPE = CTMatchType.Name;
              colorMap.clear();
              break;
            case 'Heart_v1':
              AS_ROOT_TITLE = 'Heart';
              COUNT_CSV_DATA_SOURCE = null;
              CT_MATCH_TYPE = CTMatchType.ID;
              colorMap.clear();
              break;
            case 'Kidney_v1':
              AS_ROOT_TITLE = 'Kidney';
              COUNT_CSV_DATA_SOURCE = null;
              CT_MATCH_TYPE = CTMatchType.ID;
              colorMap.clear();
              break;
            case 'Large_Intestine_v1':
              AS_ROOT_TITLE = 'Large Intestine';
              COUNT_CSV_DATA_SOURCE = null;
              CT_MATCH_TYPE = CTMatchType.ID;
              colorMap.clear();
              break;
            case 'Lymph_Node_v1':
              AS_ROOT_TITLE = 'Lymph Node';
              COUNT_CSV_DATA_SOURCE = null;
              CT_MATCH_TYPE = CTMatchType.ID;
              colorMap.clear();
              break;
            case 'Lung_v1':
              AS_ROOT_TITLE = 'Lung';
              COUNT_CSV_DATA_SOURCE = null;
              CT_MATCH_TYPE = CTMatchType.ID;
              colorMap.clear();
              break;
            case 'Spleen_v1.6':
              AS_ROOT_TITLE = 'Spleen';
              COUNT_CSV_DATA_SOURCE = './html/azimuth-spleen-cell-sets.json.csv';
              CT_MATCH_TYPE = CTMatchType.ID;
              colorMap = new Map([
                [CellSuperType.Vasculature.toString(), '#d53e4f'],
                [CellSuperType.Lymph.toString(), '#998ec3'],
                [CellSuperType.Nerve.toString(), '#99d594'],
                [CellSuperType.Others.toString(), '#fc8d59'],
                [CellSuperType.Immune.toString(), '#fee08b'],
                [CellSuperType.Connective.toString(), '#3288bd'],
                [CellSuperType.Muscle.toString(), '#999999'],
              ]);
            break;
            case 'Skin_v1':
              AS_ROOT_TITLE = 'Skin';
              COUNT_CSV_DATA_SOURCE = null;
              CT_MATCH_TYPE = CTMatchType.ID;
              colorMap.clear();
              break;
            case 'Thymus_v1':
              AS_ROOT_TITLE = 'Thymus';
              COUNT_CSV_DATA_SOURCE = null;
              CT_MATCH_TYPE = CTMatchType.ID;
              colorMap.clear();
              break;
            case 'Vasculature_v1':
              AS_ROOT_TITLE = 'Vasculature';
              COUNT_CSV_DATA_SOURCE = null;
              CT_MATCH_TYPE = CTMatchType.ID;
              colorMap.clear();
              break;
            default:
            COUNT_CSV_DATA_SOURCE = null;
            colorMap.clear();
          }
        }

        // With reference to https://stackoverflow.com/a/46403589/10283528
        function downloadSVG() {
          const svgEl = document.getElementById('svgCircles');
          svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          const svgData = svgEl.outerHTML;
          const preface = '<?xml version="1.0" standalone="no"?>\r\n';
          const svgBlob = new Blob([preface, svgData], { type: "image/svg+xml;charset=utf-8" });
          const svgUrl = URL.createObjectURL(svgBlob);
          const downloadLink = document.createElement("a");
          downloadLink.href = svgUrl;
          downloadLink.download = AS_ROOT_TITLE;
          downloadLink.click();
        }

    </script>
    <style>
      .circle:hover {
        stroke: gray !important;
        stroke-width: 3 !important;
      }
    </style>
</head>
<body onload="updateOrganSelection({ value: 'Spleen_v1.6' });generateTreemap()">
    <select name="organs" onchange="updateOrganSelection(this)">
      <option value="Brain_v1">Brain</option>
      <option value="Heart_v1" disabled title="This dataset is too large.">Heart</option>
      <option value="Kidney_v1">Kidney</option>
      <option value="Large_Intestine_v1">Large Intestine</option>
      <option value="Lymph_Node_v1">Lymph Node</option>
      <option value="Lung_v1" disabled title="This dataset is too large.">Respiratory System</option>
      <option value="Spleen_v1.6" selected="selected">Spleen</option>
      <option value="Skin_v1">Skin</option>
      <option value="Thymus_v1">Thymus</option>
      <option value="Vasculature_v1">Vasculature</option>
    </select>
    <a href="https://docs.google.com/document/d/1D7fG5brd2iq58SUU1Uv3Qdal1X8Fzhy5tRiZA0HGeII/edit?usp=sharing" style="float:right">About</a>
    <button onclick="generateTreemap()">Generate SVG</button>
    <button onclick="downloadSVG()">Download</button>
    <small style="color: gray; display: none" id="busyText">Generating bubble treemap, please wait...</small>
    <br /><br />
    <input type="radio" name="nodeLabels" id="topLeavesOpt" onchange="changeLabelingMethod(0)" checked>
    <label for="topLeavesOpt">Top 10 Leaves</label>
    <input type="radio" name="nodeLabels" id="topASNodesOpt" onchange="changeLabelingMethod(1)">
    <label for="topLeavesOpt">Top AS Nodes</label>
    <input type="radio" name="nodeLabels" id="ftuNodesOpt" onchange="changeLabelingMethod(2)">
    <label for="ftuNodesOpt">FTU Nodes</label>
    <div id="svgCirclesContainer">
        <svg id="svgCircles" width="2500px" height="1700px"></svg>
    </div>

    <div style="position: absolute; left:20px; bottom:40px;display:none" id="paddingSliderContainer">
        Padding: <input style="background:grey;position: absolute; left:100px" type="range" min="0" max="100" value="10" class="slider" id="paddingSlider" onchange="generateTreemap()">
    </div>
    <div style="position: absolute; left:20px; bottom:80px;display:none" id="curvatureSliderContainer">
        Smoothness: <input style="background:grey;position: absolute; left:100px" type="range" min="1" max="100" value="10" class="slider" id="curvatureSlider" onchange="generateTreemap()">
    </div>
</body>
</html>
